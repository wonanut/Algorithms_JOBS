# C/C++基础面试题

[TOC]

## sizeof和strlen有哪些区别⭐⭐

注意！！sizeof不能用来计算字符串长度！！！

1. sizeof是操作符，strlen是函数。sizeof后如果是类型，必须加括弧；如果是变量名，可以不加括弧。

2. sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型，保证能容纳实现所建立的最大对象的字节大小。

3. sizeof可以用类型做参数（还可以用函数做参数），strlen只能用hcar*做参数，且必须是以"\0"结尾的。

   ```c
   short fun();
   printf("%d \n", sizeof(fun())); // 输出2
   ```

4. 数组做sizeof的参数不退化，传递给strlen就退化为指针了。

   - 对以数组为形参的函数，传过去之后实参都变成数组首地址，即为退化。而sizeof不是函数，所以保留数组特性不退化。

5. 大部分编译程序在编译的时候sizeof就被计算过了，这就是sizeof(x)可以用来定义数组维数的原因。strlen的结果要在运行时才计算出来，它用来计算字符串的长度，不是类型占内存的大小。

6. 在计算字符串数组的长度上有区别，如：

   ```c
   char str[20]="0123456789";
   int a = sizeof(str);  //10
   int b = strlen(str);  //20，求的是数组所占内存空间大小
   ```

7. 如果要计算指针所指向的字符串的长度，则一定要用strlen。如：

   ```c
   char *ss = "0123456789";
   int a = sizeof(ss); //4, 计算的是ss指针所占用的内存空间大小。
   int b = strlen(ss); //10，计算的是ss指针所指向的字符串的长度。
   ```

## 指针和引用有什么区别⭐⭐

1. 初始化要求不同
   - 引用在创建时必须初始化，即引用到一个有效的对象。
   - 指针在定义时不必初始化，可以在定义后面的任何地方重新赋值。
2. 可修改性不同
   - 引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用。给引用赋值并不是改变它和原始对象的绑定关系。
   - 指针可以在任何时候改变为指向另一个对象。
3. NULL的使用
   - 不存在NULL引用，引用不能使用指向空值的引用，它必须总是指向某个对象
   - 指针可以是NULL，可以把指针指向任意的对象，所以指针更灵活，也更易错
4. 测试需要区别
   - 引用不会指向空值，所以使用引用之前不需要测试它的合法性
   - 指针需要经常进行合法性测试
   - 使用引用的代码效率比使用指针要高
5. 应用的区别
   - 引用：适用于一旦指向一个对象之后就不会改变指向
   - 指针：有存在指向NULL（不指向任何对象）或在不同的时刻指向不同对象

## 指针常量和常量指针的区别⭐⭐

- 常量指针，“是常量的**指针**”。

  - 首先应该是一个指针，是一个指向常量的指针，指针所指向的地址的内容是不可修改的。往往是为了防止写程序过程中对指针误操作出现了修改常量的错误，编译系统会提示我们出错信息。
  - 常量指针指向的内容不能通过指针修改，但是指针指向的值可以改变。

  ```c
  int a, b;
  const int* p = &a;  //常量指针
  int const *p2 = &a;  //常量指针，如果const位于*左侧，则const是用来修饰指针所指向的常量，指针指向的是常量。
  *p = 2; //error
  p = &b; //right
  ```

  

- 指针常量，“是指针的**常量**”

  - 首先是一个常量，然后这个常量是指针，不能修改指针所指向的地址，一旦初始化，不能再被赋值。
  - 指针常量是不可改变地址的指针，但是可以对它所指向的内容进行更改。

  ```c
  int a, b;
  int* const p = &a; //指针常量，定义时必须初始化
  p = &a; //error
  *p = 2; //right
  ```

- 定义一个指向常量的指针常量

  ```c
  int a;
  const int* const = &a;
  ```

  

