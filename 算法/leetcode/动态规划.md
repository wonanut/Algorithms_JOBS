# 32.æœ€é•¿æœ‰æ•ˆæ‹¬å·

é¢˜ç›®ï¼šç»™å®šä¸€ä¸ªåªåŒ…å« `'('` å’Œ `')'` çš„å­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºæœ€é•¿çš„åŒ…å«æœ‰æ•ˆæ‹¬å·çš„å­ä¸²çš„é•¿åº¦ã€‚

```
è¾“å…¥: ")()())"
è¾“å‡º: 4
è§£é‡Š: æœ€é•¿æœ‰æ•ˆæ‹¬å·å­ä¸²ä¸º "()()"
```

## ï¼ˆ1ï¼‰å·¦å³å„æ‰«æä¸€é

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        l = len(s)
        left = 0; right=0
        maxLen = 0;resLen = 0
        for i in range(l):
            if(s[i]=='('):
                left += 1
            elif(s[i]==')'):
                right += 1
            if(right==left):
                maxLen = left+right
                resLen = max(resLen,maxLen)
            elif(right>left):
                resLen = max(resLen,maxLen)
                maxLen = 0
                left  = 0
                right = 0
            
        j = l-1;maxLen = 0;left = 0;right = 0
        while(j>=0):
            if(s[j]=='('):
                left += 1
            elif(s[j]==')'):
                right += 1
            if(left == right):
                maxLen = left+right
                resLen = max(resLen,maxLen)
            elif(left>right):
                resLen = max(resLen,maxLen)
                maxLen = 0
                left = 0
                right = 0
            j-=1
        return resLen
                
            
```

æ—¶é—´å¤æ‚åº¦o(n),ä¸¤æ¬¡éå†ã€‚

ç©ºé—´å¤æ‚åº¦o(1)

## (2)åŠ¨æ€è§„åˆ’

å¾…è¡¥ã€‚

## (3)æ ˆ

æ€è·¯ï¼šåˆ©ç”¨ä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªæ”¾æ‹¬å·ï¼Œä¸€ä¸ªæ”¾ä¸‹æ ‡ã€‚è®°å½•æ‹¬å·å‡ºæ ˆæ—¶åŒ¹é…å¯¹çš„ä¸‹æ ‡ï¼Œå°†å¾—åˆ°çš„ä¸‹æ ‡è¿›è¡Œæ’åºï¼Œå…¶ä¸­æœ€é•¿è¿ç»­å­åºåˆ—çš„é•¿åº¦å°±æ˜¯æœ‰æ•ˆæ‹¬å·çš„é•¿åº¦ã€‚

```
ä¾‹å¦‚ï¼šs = )(()())ï¼Œæˆ‘ä»¬ç”¨æ ˆå¯ä»¥æ‰¾åˆ°ï¼Œ

ä½ç½® 2 å’Œä½ç½® 3 åŒ¹é…ï¼Œ

ä½ç½® 4 å’Œä½ç½® 5 åŒ¹é…ï¼Œ

ä½ç½® 1 å’Œä½ç½® 6 åŒ¹é…ï¼Œ

è¿™ä¸ªæ•°ç»„ä¸ºï¼š2,3,4,5,1,6 ï¼Œè¯¥æ•°ç»„ç”¨æ ˆæ‰¾åˆ°çš„ï¼Œç„¶åæŒ‰é€’å¢æ’åºï¼š1,2,3,4,5,6

è¿ç»­é€’å¢å­åºåˆ—çš„é•¿åº¦ä¸º6ï¼ˆé€’å¢å€¼ä¸º1ï¼‰

```

```python
#python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        popIndex = []
        stack = [];indexStack = []
        l = len(s)
        for i in range(l):
            if(s[i]=='('):
                stack.append('(');indexStack.append(i)
            elif(s[i]==')' and len(stack)!=0):
                stack.pop()
                popIndex.append(indexStack[-1])
                popIndex.append(i)
                indexStack.pop()
        popIndex.sort()
        ans = 0;res = 0
        for i in range(len(popIndex))[1:]:
            if(popIndex[i]-popIndex[i-1]==1):
                ans += 1
                res = max(res,ans)   
            else:
                res = max(res,ans)
                ans = 0
        if(res>0):
            res+=1
        return res
                
            
```

æ—¶é—´å¤æ‚åº¦ï¼šo(n+nlogn),o(n)ä¸ºä¸¤æ¬¡éå†ï¼Œo(nlogn)ä¸ºæ’åº

ç©ºé—´å¤æ‚åº¦ï¼šo(n)

# 53.æœ€å¤§å­åºå’Œ

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œæ‰¾åˆ°ä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚

```
è¾“å…¥: [-2,1,-3,4,-1,2,1,-5,4],
è¾“å‡º: 6
è§£é‡Š: è¿ç»­å­æ•°ç»„ [4,-1,2,1] çš„å’Œæœ€å¤§ï¼Œä¸º 6ã€‚
```

## ï¼ˆ1ï¼‰æš´åŠ›  (O(n^2))è¶…æ—¶

```python
#python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        l = len(nums)
        max = 0
        for i in range(l):
            tmp = 0;j = i
            while(j < l):
                tmp += nums[j]
                if(max<tmp):
                    max = tmp
        return max
                
            
        
```

## ï¼ˆ2ï¼‰åŠ¨æ€è§„åˆ’o(n)

```python
#python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        l = len(nums)
        if(max(nums)<0):
            return max(nums)
        maxVal = 0;tmp=0;
        for i in range(l):
            tmp += nums[i]
            if(tmp<0):
                tmp = 0
            maxVal = max(tmp,maxVal)
        return maxVal
```

# 70.çˆ¬æ¥¼æ¢¯

é¢˜ç›®ï¼š

```
å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ *n* é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚

æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ

**æ³¨æ„ï¼š**ç»™å®š *n* æ˜¯ä¸€ä¸ªæ­£æ•´æ•°
è¾“å…¥ï¼š 2
è¾“å‡ºï¼š 2
è§£é‡Šï¼š æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶ã€‚
1.  1 é˜¶ + 1 é˜¶
2.  2 é˜¶

è¾“å…¥ï¼š 3
è¾“å‡ºï¼š 3
è§£é‡Šï¼š æœ‰ä¸‰ç§æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶ã€‚
1.  1 é˜¶ + 1 é˜¶ + 1 é˜¶
2.  1 é˜¶ + 2 é˜¶
3.  2 é˜¶ + 1 é˜¶
```
**æ­£ç¡®codeï¼š**

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [0]*(n+1)
        if(n==1):
            return 1
        elif(n==2):
            return 2
        dp[1] = 1; dp[2] = 2
        for i in range(n+1)[3:]:
            dp[i] = dp[i-1]+dp[i-2]
        return dp[n]
```

æ—¶é—´å¤æ‚åº¦o(n)

# 62.æœ€çŸ­è·¯å¾„

2019/12/3 æ›´æ–°

**é¢˜ç›®ï¼š**

ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œStartâ€ ï¼‰ã€‚

æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œFinishâ€ï¼‰ã€‚

é—®æ€»å…±æœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ
![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

ä¾‹å¦‚ï¼Œä¸Šå›¾æ˜¯ä¸€ä¸ª7 x 3 çš„ç½‘æ ¼ã€‚æœ‰å¤šå°‘å¯èƒ½çš„è·¯å¾„ï¼Ÿ

**è¯´æ˜ï¼š***m*å’Œ *n* çš„å€¼å‡ä¸è¶…è¿‡ 100ã€‚

```
è¾“å…¥: m = 3, n = 2
è¾“å‡º: 3
è§£é‡Š:
ä»å·¦ä¸Šè§’å¼€å§‹ï¼Œæ€»å…±æœ‰ 3 æ¡è·¯å¾„å¯ä»¥åˆ°è¾¾å³ä¸‹è§’ã€‚
1. å‘å³ -> å‘å³ -> å‘ä¸‹
2. å‘å³ -> å‘ä¸‹ -> å‘å³
3. å‘ä¸‹ -> å‘å³ -> å‘å³
```

æˆ‘çš„ä»£ç ,62ä¸ªæµ‹è¯•ç”¨ä¾‹144msï¼š

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        import numpy 
        dp = numpy.zeros((m,n))
        dp[0][0] = 1
        for i in range(m):
            for j in range(n):
                if(i == 0 and j != 0):
                    dp[i][j] = dp[i][j-1]
                elif(i != 0 and j == 0):
                    dp[i][j] = dp[i-1][j]
                elif(i > 0 and j > 0):
                    dp[i][j] = dp[i-1][j]+dp[i][j-1]
        return int(dp[m-1][n-1])
```

å¤§ä½¬çš„ä»£ç ï¼Œ62ä¸ªæµ‹è¯•ç”¨ä¾‹20msè¿è¡Œï¼š

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        
        if m < 0 or n < 0:
            return 0
        if m == 1 or n == 1:
            return 1
        
        dp = [[0 for i in range(m)] for j in range(n)]
        
        for i in range(m):
            for j in range(n):
                if i == j == 0:
                    dp[j][i] = 0
                elif i == 0 or j == 0:
                    dp[j][i] = 1
                else:
                    dp[j][i] = dp[j][i - 1] + dp[j - 1][i]
        
        return dp[n - 1][m - 1]
```

æ—¶é—´å¤æ‚åº¦ï¼šo(n^2)

çœ‹ç€ä»£ç é•¿åº¦éƒ½å·®ä¸å¤šï¼Œé€»è¾‘ä¹Ÿä¸€æ ·ï¼Œä¸ºä»€ä¹ˆå°±æ¯”äººå®¶æ…¢é‚£ä¹ˆå¤šå‘¢ã€‚äºæ˜¯æˆ‘æŠŠè‡ªå·±ç”¨numpyç”ŸæˆçŸ©é˜µçš„è¯­å¥æ¢æˆäº†dp = [[0 for i in range(m)] for j in range(n)]ï¼ŒçœŸçš„å¿«äº†å¥½å¤šï¼

![image-20191203102816553](/Users/qinxiuxin/Library/Application Support/typora-user-images/image-20191203102816553.png)

å¥½å¥½å­¦åµŒå¥—åˆ—è¡¨æ¨å¯¼å¼å§ï¼

# 63.æœ€çŸ­è·¯å¾„äºŒ

2019/12/3 æ›´æ–°

é¢˜ç›®ï¼š**

ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œStartâ€ ï¼‰ã€‚

æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œFinishâ€ï¼‰ã€‚

ç°åœ¨è€ƒè™‘ç½‘æ ¼ä¸­æœ‰éšœç¢ç‰©ã€‚é‚£ä¹ˆä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’å°†ä¼šæœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

ç½‘æ ¼ä¸­çš„éšœç¢ç‰©å’Œç©ºä½ç½®åˆ†åˆ«ç”¨ `1` å’Œ `0` æ¥è¡¨ç¤ºã€‚

**è¯´æ˜ï¼š***m* å’Œ *n* çš„å€¼å‡ä¸è¶…è¿‡ 100ã€‚

```
è¾“å…¥:
[
Â  [0,0,0],
Â  [0,1,0],
Â  [0,0,0]
]
è¾“å‡º: 2
è§£é‡Š:
3x3 ç½‘æ ¼çš„æ­£ä¸­é—´æœ‰ä¸€ä¸ªéšœç¢ç‰©ã€‚
ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’ä¸€å…±æœ‰ 2 æ¡ä¸åŒçš„è·¯å¾„ï¼š
1. å‘å³ -> å‘å³ -> å‘ä¸‹ -> å‘ä¸‹
2. å‘ä¸‹ -> å‘ä¸‹ -> å‘å³ -> å‘å³

```

åŸºäºä¸Šé¢æ‹¿åˆ°é¢˜ç›®ï¼Œäºæ˜¯æŠŠè‡ªå·±ç”ŸæˆçŸ©é˜µçš„ä¹ æƒ¯æ”¹æˆåˆ—è¡¨è§£æå¼çš„æ–¹æ³•ç”Ÿæˆï¼Œ43ä¸ªæµ‹è¯•ç”¨ä¾‹48msï¼š

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        dp = [[0 for i in range(n)] for j in range(m)]
        if(obstacleGrid[0][0]==1):
            dp[0][0] = 0
        else:
            dp[0][0] = 1
        for i in range(m):
            for j in range(n):
                if(i==0 and j != 0 and obstacleGrid[i][j]!= 1 ):
                    dp[i][j] = dp[i][j-1]
                elif(i != 0 and j==0 and obstacleGrid[i][j]!= 1):
                    dp[i][j] = dp[i-1][j]
                elif(i >0 and j > 0 and obstacleGrid[i][j] != 1):
                    dp[i][j] = dp[i-1][j]+dp[i][j-1]
        return int(dp[m-1][n-1])
```



å¤§ç¥çš„ä»£ç ï¼Œ43ä¸ªæµ‹è¯•ç”¨ä¾‹40msï¼š

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        dp = obstacleGrid[:][:]
        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0
        for i in range(1,m):
            dp[i][0] = dp[i-1][0] if obstacleGrid[i][0] == 0 else 0
        for j in range(1,n):
            dp[0][j] = dp[0][j-1] if obstacleGrid[0][j] == 0 else 0
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1] if obstacleGrid[i][j] == 0 else 0
        return dp[-1][-1]
            
```

æ³¨æ„ï¼šä»¥åå†™ä»£ç å°½é‡ç”¨æ¡ä»¶è¡¨è¾¾å¼çš„å½¢å¼ï¼Œåˆ—è¡¨èƒ½ç”¨è§£æå¼ç”Ÿæˆå°±ç”¨è§£æå¼ï¼Œä¼šå¿«å¾ˆå¤šã€‚åŸæ¥43ä¸ªæµ‹è¯•ç”¨ä¾‹168msçš„ä»£ç æ‹¯æ•‘åˆ°äº†48msï¼Œå¤šå‘å¤§ç¥å­¦ä¹ ï¼

# 64.æœ€å°è·¯å¾„å’Œ

2019/12/3 æ›´æ–°

é¢˜ç›®ï¼š**

ç»™å®šä¸€ä¸ªåŒ…å«éè´Ÿæ•´æ•°çš„ *m* x *n* ç½‘æ ¼ï¼Œè¯·æ‰¾å‡ºä¸€æ¡ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„è·¯å¾„ï¼Œä½¿å¾—è·¯å¾„ä¸Šçš„æ•°å­—æ€»å’Œä¸ºæœ€å°ã€‚

**è¯´æ˜ï¼š**æ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚

```
è¾“å…¥:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
è¾“å‡º: 7
è§£é‡Š: å› ä¸ºè·¯å¾„ 1â†’3â†’1â†’1â†’1 çš„æ€»å’Œæœ€å°ã€‚
```

ä»£ç ï¼š

61ä¸ªæµ‹è¯•ç”¨ä¾‹220msğŸ˜­

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        import numpy 
        m = len(grid)
        n = len(grid[0])
        dp = [[0 for i in range(n)] for j in range(m)]
        dp[0][0] = grid[0][0]
        for i in range(m):
            for j in range(n):
                if(i ==0 and j > 0):
                    dp[i][j] = dp[i][j-1]+grid[i][j]
                elif(i>0 and j==0):
                    dp[i][j] = dp[i-1][j]+grid[i][j]
                elif(i > 0 and j > 0):
                    dp[i][j] = min(dp[i-1][j],dp[i][j-1])+grid[i][j]
        return int(dp[m-1][n-1])
```

å¤§ç¥100msè¿‡61ä¸ªæµ‹è¯•æ•°æ®çš„ä»£ç ï¼š

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        res = [[grid[_][0]]+[0]*(n-1) for _ in range(m)]
    
        for i in range(1,n):
            res[0][i] = grid[0][i]+res[0][i-1]
          
        for j in range(1,m):
            res[j][0] = grid[j][0] + res[j-1][0]
    
        for i in range(1,m):
            for j in range(1,n):
                res[i][j] = grid[i][j] + min(res[i-1][j], res[i][j-1])  
        return res[-1][-1]
```

ä»£ç é€»è¾‘éƒ½å·®ä¸å¤šï¼Œæœ€å¥½è¿˜æ˜¯æŠŠifå•ç‹¬å¤„ç†çš„æ”¾åœ¨å¾ªç¯å¤–é¢ç»Ÿä¸€å¤„ç†ï¼Œå¦åˆ™æ¯æ¬¡éƒ½è¦åšä¸€æ¬¡if åˆ¤æ–­ã€‚