# 101.å¯¹ç§°äºŒå‰æ ‘

é¢˜ç›®ï¼š

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ `[1,2,2,3,4,4,3]` æ˜¯å¯¹ç§°çš„ã€‚

```
    1
   / \
  2   2
 / \ / \
3  4 4  3æ˜¯å¯¹ç§°çš„  
		1
   / \
  2   2
   \   \
   3    3æ˜¯ä¸å¯¹ç§°çš„

```

æˆ‘å†™çš„12msçš„ä»£ç ï¼ˆç¬‘å“­ðŸ˜‚ï¼‰

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root==NULL)
            return true;
        else if(root->left==NULL && root->right==NULL)
            return true;
        else if(root->left==NULL || root->right==NULL)
            return false;
        else
            return isSym(root,root);
        return true;
    }
    bool isSym(TreeNode* root1,TreeNode* root2){
        if(root1==NULL&&root2==NULL)
            return true;
        if(root1==NULL || root2==NULL)
            return false;
        if(root1->val == root2->val)     
            return isSym(root1->left,root2->right)&&isSym(root1->right,root2->left);
        return false;
    }
};
```

è´´ä¸€ä¸ªå¤§ç¥žå†™çš„0msçš„ä»£ç 

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root != NULL){
             return isSymmetric_helper(root->left, root->right);
        }
        else {
            return true;
        }
    }
    bool isSymmetric_helper(TreeNode * n1, TreeNode *n2){
        if(n1 == NULL && n2 == NULL){
            return true;
        }
        if(n1 != NULL && n2 != NULL && (n1->val == n2->val)){
            return isSymmetric_helper(n1->left, n2->right) && isSymmetric_helper(n1->right, n2->left);
        }
        else{
            return false;
        }
    }
};
```

# 102.äºŒå‰æ ‘çš„å±‚æ¬¡éåŽ†

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›žå…¶æŒ‰å±‚æ¬¡éåŽ†çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»Žå·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

ä¾‹å¦‚:
ç»™å®šäºŒå‰æ ‘: `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
è¿”å›žå…¶å±‚æ¬¡éåŽ†çš„ç»“æžœï¼š
[
  [3],
  [9,20],
  [15,7]
]
```

æˆ‘çš„56msçš„ä»£ç ðŸ˜‚

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if(root==None):
            return []
        ans = []
        from queue import Queue
        que = Queue()
        que.put(root)
        curNodeNum = 1
        nextNodeNum = 0
        while(not que.empty()):
            lev=[]
            nextNodeNum = 0
            while(curNodeNum):
                top = que.get()
                lev.append(top.val)
                curNodeNum-=1
                if(top.left):
                    que.put(top.left)
                    nextNodeNum +=1
                if(top.right):
                    que.put(top.right)
                    nextNodeNum +=1
            curNodeNum = nextNodeNum
            ans.append(lev)
        return ans
```

å¤§ä½¬28msçš„ä»£ç ï¼š

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []
        def helper(root,depth):
            if not root: return
            if len(res) == depth: res.append([])
            res[depth].append(root.val)
            helper(root.left,depth+1)
            helper(root.right,depth+1)
        helper(root,0)
        return res
```

# 107.äºŒå‰æ ‘çš„å±‚æ¬¡éåŽ†ï¼ˆ2ï¼‰

é¢˜ç›®ï¼š

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›žå…¶èŠ‚ç‚¹å€¼è‡ªåº•å‘ä¸Šçš„å±‚æ¬¡éåŽ†ã€‚ ï¼ˆå³æŒ‰ä»Žå¶å­èŠ‚ç‚¹æ‰€åœ¨å±‚åˆ°æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„å±‚ï¼Œé€å±‚ä»Žå·¦å‘å³éåŽ†ï¼‰

ä¾‹å¦‚ï¼š
ç»™å®šäºŒå‰æ ‘ [3,9,20,null,null,15,7],

```
    3
   / \
  9  20
    /  \
   15   7
è¿”å›žå…¶è‡ªåº•å‘ä¸Šçš„å±‚æ¬¡éåŽ†ä¸ºï¼š
[
  [15,7],
  [9,20],
  [3]
]
```

æˆ‘52msçš„ä»£ç ðŸ˜‚

```python
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if(root==None):
            return []
        ans = []
        from queue import Queue
        que = Queue()
        que.put(root)
        curNodeNum = 1
        nextNodeNum = 0

        while(not que.empty()):
            lev=[]
            nextNodeNum = 0
            while(curNodeNum):
                top = que.get()
                lev.append(top.val)
                curNodeNum-=1
                if(top.left):
                    que.put(top.left)
                    nextNodeNum +=1
                if(top.right):
                    que.put(top.right)
                    nextNodeNum +=1
            curNodeNum = nextNodeNum
            ans.append(lev)
        ans.reverse()
        return ans  
```

å¤§ä½¬28msçš„ä»£ç 

```python
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        queue = [] 
        cur = [root] 
        while cur:
            cur_layer_val = []
            next_layer_node = []
            for node in cur:
                if node:
                    cur_layer_val.append(node.val)
                    next_layer_node.extend([node.left, node.right]) 
            if cur_layer_val:
                queue.insert(0, cur_layer_val)
            cur = next_layer_node
        return queue      
```

# 111.äºŒå‰æ ‘çš„æœ€å°æ·±åº¦

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚

æœ€å°æ·±åº¦æ˜¯ä»Žæ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚

è¯´æ˜Ž: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

```
    3
   / \
  9  20
    /  \
   15   7
è¿”å›žå®ƒçš„æœ€å°æ·±åº¦  2.
```

æˆ‘60msçš„ä»£ç ðŸ˜‚

```python
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if(root == None):
            return 0
        def bfs(root):
            from queue import Queue
            que = Queue()
            que.put(root)
            nowLevel = 1
            curNode = 1
            nextNode = 0
            while(not que.empty()):
                nextNode = 0
                while(curNode):
                    top=que.get()
                    curNode -= 1
                    if(top.left==None and top.right == None):
                        return nowLevel
                    if(top.left):
                        que.put(top.left)
                        nextNode+=1
                    if(top.right):
                        que.put(top.right)
                        nextNode+=1
                curNode = nextNode
                nowLevel += 1
            return nowLevel
        return bfs(root)            
            
```

å¤§ä½¬40msçš„ä»£ç 

```python
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        depth = 1
        queue = [root]
        while len(queue)>0:
            ct = len(queue)
            for i in range(ct):
                t = queue[i]
                if t.left is None and t.right is None:
                    return depth
                if t.left is not None:
                    queue += [t.left]
                if t.right is not None:
                    queue += [t.right]
            queue = queue[ct:]
            depth+=1
        return depth
```

